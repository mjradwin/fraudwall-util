/**
 * Copyright (c) 2010, Anchor Intelligence. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 *
 * - Neither the name of Anchor Intelligence nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.fraudwall.util.db;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.Iterator;

import com.fraudwall.util.Require;

/**
 * Provides an {@link Iterator} on an underlying {@link Reader}
 * containing SQL statements. Each call to the {@link #next} method
 * returns the next SQL statement in the file (as a {@link String}).
 * <p>
 * The SQL parsing provided by this class is simple-minded. First,
 * all comment lines and blank lines are ignored. Comment lines are
 * defined as lines starting with any number of white space characters
 * (space or TAB) followed by the characters "--", and blank lines are
 * defined as lines containing all white space characters. Second, SQL
 * statements are terminated by lines ending with ";". The trailing
 * semi-colon is stripped from the result returned by the {@link #next}
 * method. Third, SQL statements may span multiple lines. Newlines are
 * stripped from multi-line statements in the String returned by
 * {@link #next}. Blank and comment lines may appear within
 * multi-line statements.
 * <p>
 * For example, if the input Reader contains the following lines:
 * <pre>
 * -- DO NOT EDIT THIS FILE!
 * -- generated from Country.xml
 *
 * DROP TABLE IF EXISTS countries;
 * CREATE TABLE countries(
 *   -- unique identifier
 *   id CHAR(2)
 *   -- country name
 *  ,name VARCHAR(255)
 * );
 *
 * -- end of generated file
 * </pre>
 * subsequent calls of the {@link #next} method will return the
 * following strings in the following order:
 * <pre>
 * DROP TABLE IF EXISTS countries
 * CREATE TABLE countries(  id CHAR(2) ,name VARCHAR(255))
 * </pre>
 * <p>
 * The methods of this class are <em>not</em> thread-safe; clients
 * must provide their own synchronization to prevent race conditions
 * in the case of multi-threaded access.
 *
 * @author Allan Heydon
 */
public class SqlStatementIterator implements Iterator<String> {
	private static final String STATEMENT_SUFFIX = ";";

	private static final String COMMENT_PREFIX = "--";

	/* BufferedReader to read from. May be null, which indicates
	 * the reader has been closed.
	 */
	private BufferedReader br;

	/* StringBuilder in which SQL statements are constructed. Set
	 * to null by {@link #advance} when there are no more SQL statements
	 * to be read.
	 */
	private StringBuilder sb;

	/**
	 * Constructs a new SqlStatementIterator that will read SQL
	 * statements from the supplied reader.
	 *
	 * @param r The underlying reader from which to read SQL statements.
	 */
	public SqlStatementIterator(Reader r) {
		br = new BufferedReader(r);
		sb = new StringBuilder(100);
		advance();
	}

	/**
	 * Deallocates all resources associated with this iterator,
	 * including the underlying Reader that was passed to the
	 * constructor. To avoid a resource leak, this method should
	 * be called on the iterator in cases where it is not fully
	 * exhausted (i.e., in cases where no call of {@link #hasNext}
	 * was performed that returned false). If the iterator is
	 * exhausted by the client, calling this method is a no-op.
	 */
	public void close() {
		if (br != null) {
			try {
				br.close();
			} catch (IOException ex) {
				throw new RuntimeException(ex);
			} finally {
				br = null;
			}
		}
	}

	public boolean hasNext() {
		return (sb != null);
	}

	public String next() {
		Require.isNotNull(sb, "Attempt to call next() on exhausted SqlStatementIterator");
		String res = sb.toString();
		advance();
		return res;
	}

	public void remove() {
		throw new UnsupportedOperationException("Cannot remove() from SqlStatementIterator");
	}

	/**
	 * Reads the next SQL statement from the input into <code>sb</code>,
	 * or sets <code>sb</code> to null if there are no more statements to read.
	 */
	private void advance() {
		try {
			advanceInner();
		} catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}

	private void advanceInner() throws IOException {
		// skip blank and comment lines
		String line = br.readLine();
		while (line != null && (isIgnoreLine(line))) {
			line = br.readLine();
		}

		// return if EOF reached
		if (line == null) {
			sb = null;
			close();
			return;
		}

		// otherwise, read the next statement into "sb"
		sb.setLength(0);
		while (isIgnoreLine(line) || !line.endsWith(STATEMENT_SUFFIX)) {
			if (!isIgnoreLine(line)) {
				sb.append(line).append(' ');
			}
			line = br.readLine();
			Require.isNotNull(line, "Encountered EOF before multi-line SQL statement was terminated.");
		}
		sb.append(line.substring(0, line.length() - 1));
	}

	private static boolean isIgnoreLine(String line) {
		for (int i = 0; i < line.length(); i++) {
			char c = line.charAt(i);
			if (c != ' ' && c != '\t') {
				return line.substring(i).startsWith(COMMENT_PREFIX);
			}
		}
		return true;
	}
}
